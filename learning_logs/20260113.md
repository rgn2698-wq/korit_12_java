# Java Generic Wildcard
## 제네릭

```java
public class Box<T> {
    // field 선언
    private T value;
    public void setValue(T value) {
        this.value = value;
    }
    public T getvalue() {
        return value;
    }
}
```
와 같은 방식으로 작성했을때 value의 자료형을 고정 시키지않고 사용 가능함. 
- 예를 들어 value에 String / Integer / Double / Product / Item ... etc 등으로 사용가능. 즉 Java 객체의 자료형 뿐만 아니라 개발자가 정의한 것도 집어넣을수 있음. 이는 후추 백엔드 설계에도 매우 중요.

## 와일드 카드
- 이상의 제네릭 타입을 사용할때 구체적인 타입을 명시하지않고 범용적으로 처리하고싶을때 사용. `?`를 사용함.
```java
public static void main(String[] args) {
    List<?> exampleList = new ArrayList<String>();
}
```

### 종류
1. 모든 타임 허용
    - 읽기 전용. 어떤 타입이든지 일반 받아놓고 분류해야 할 때
2. T 또는 T의 서브 타입(지식 클래스)
    - 읽기 전용. 제한된 타입에서 읽을 때
3. T 또는 T의 슈퍼 타입(부모 클래스)
    - 쓰기 전용. 제한된 타입으로 넣을때


# Collections
- 여러 객체들을 모아둔 것들을 의미함 -> 배열과는 약간 차이가 있음.
- 다만 Java에서의 list는 python에서의 List와도 차이가 있음.
```java
List<Person> list1 = new ArrayList<>();
```
## 종류
1. List : 순서가 있는 데이터의 집합으로 중복된 요소를 허락함.
    - ArratList : 배열 기반의 리스트, element 접근 속도가 빠름.
    - LinkedList : 연결 리스트, 삽입 / 삭제 속도가 빠름.
2. Set : 중복을 허용하지 않는 (List와의 차이 #1) 데이터 들의 집합 (중 1때 배우는 그 집함.)
    - HashSet : 해시 테이블 기반의 집합. element의 순서를 보장하지 않음(List 와의 차이 #2)
    - TreeSet : 이전 검색 트리 기반의 집함. element가 정렬된 상태로 유지됨.
3. Map : Ket / Value 쌍으로 이루어진 데이터 들의 집합.
    - HashMap : 해시 테이블 기반의 맵. 키의 순서를 보장하지 않음
    - TreeMap : 이진검색트리기반의 맵. 키가 정렬된 상태로 유지.

### 참조 : JavaScript에서의 객체 정의 방식
```js
const person1 = {
    name : "김일",
    age : 20
};
```
- Java에서의 Map과 유사한 형태를 가짐.(추후 수업 예정)
- 근데 JavaScript 에서의 key-value 쌍을 property라고 부름.
- 근데 Java에서의 map의 key-value 쌍을 또 entry라고 부름.
- 그러면 이 부분 이해했다고 치고 Java는 객체에서 field와 field의 value라고 볼수 있음.
- 근데 JS에서는 property의 key-value라고 봐야함.
- 근데 또 python에서는 attribute의 value임.
