# [과제] 판타지 RPG 무기 교체 시스템 구현

### 1. 과제 시나리오

당신은 대작 RPG 게임의 서버 개발자입니다. 플레이어는 최대 10개의 무기를 '무기 슬롯(Weapon Inventory)'에 소지할 수 있습니다.
전투 중에는 상황에 맞춰 무기를 빠르게 교체해야 하며, 각 무기는 공통적인 '공격' 동작 외에 무기 종류별 고유 특수 기술을 가지고 있습니다.

다형성(Polymorphism)을 활용하여 유연한 무기 관리 시스템을 구축하고, 특정 무기를 들었을 때만 발동되는 특수 기술 로직을 구현하세요.

### 2. 상세 가이드라인

#### [단계 1] 공통 규약 인터페이스 `Weapon` 정의

* `game.items` 패키지를 생성하세요.
* `Weapon` 인터페이스를 정의하고, 모든 무기가 반드시 가져야 할 공통 동작인 `attack()` 추상 메서드를 선언하세요.
* `void attack();`

#### [단계 2] 무기 클래스 구현 (업캐스팅 대상)

* `Weapon` 인터페이스를 구현하는 3가지 무기 클래스를 만드세요.
1. Sword (검)
* `attack()`: "검을 크게 휘두릅니다!" 출력
* 고유 메서드 `parry()`: "검으로 적의 공격을 막아냅니다!" 출력


2. Bow (활)
* `attack()`: "화살을 날립니다!" 출력
* 고유 메서드 `snipe()`: "멀리 있는 적을 저격합니다!" 출력


3. Staff (지팡이)
* `attack()`: "마법 구체를 던집니다!" 출력
* 고유 메서드 `castSpell()`: "광역 마법을 시전합니다!" 출력


#### [단계 3] 인벤토리 시스템 `Inventory` 구현

* `game.system` 패키지에 `Inventory` 클래스를 만드세요.
* 필드: `Weapon[] weaponSlots` (크기는 생성자에서 지정)
* 메서드 1: `addWeapon(Weapon weapon)`
* 배열의 비어있는 공간을 찾아 무기를 추가합니다. (업캐스팅 발생)
* 꽉 찼다면 "인벤토리가 가득 찼습니다."를 출력하세요.

* 메서드 2: `attackAll()`
* 반복문을 통해 현재 소지한 모든 무기로 한 번씩 공격(`attack()`)을 수행합니다.

#### [단계 4] 특수 기술 발동 `useSpecialAbilities()` (다운캐스팅 핵심)

* `Inventory` 클래스에 `useSpecialAbilities()` 메서드를 추가하세요.
* 배열을 순회하면서 각 무기의 실제 타입(instanceof)을 확인하세요.
* 타입에 맞게 다운캐스팅(Downcasting)을 수행한 후, 각 무기의 고유 메서드(`parry`, `snipe`, `castSpell`)를 호출하세요.

### 4. 핵심 학습 포인트 (수강생 안내용)

1. 배열의 타입: `Sword`, `Bow`는 서로 다른 클래스이지만, `Weapon`이라는 공통 인터페이스로 묶어서 `Weapon[]` 배열 하나에 담을 수 있다는 점(업캐스팅)을 이해해야 합니다.
2. 고유 기능 접근 불가: 업캐스팅된 상태(`Weapon` 타입)에서는 `weapon.parry()` 처럼 하위 클래스의 고유 메서드를 바로 호출할 수 없음을 인지해야 합니다.
3. 안전한 변환: `instanceof` 없이 무작정 `(Sword) weapon`으로 변환하면, 만약 그 무기가 `Bow`였을 경우 `ClassCastException` 오류가 발생하여 게임이 튕기게 됩니다. 이를 방지하는 방어 코드를 작성하는 것이 핵심입니다.

# 싱글톤 Singleton

## 정의
- 소프트웨어 `디자인 패턴` 중 하나로 어떤 클래스가 `하나의 인스턴스만 갖도록 보장하고,` 그 인스턴스에 접근 할수있는 `전역적인 접근법`을 제공하는 패턴. 예를 들어, 데이터베이스 연결에 같은 리소스는 프로그램 전체에서 하나의 인스턴스만 사용해야 할 때가 많기 때문에 싱글톤 패턴을 사용함.

## 특징
1. 하나의 인스턴스만 존재 : 하나의 인스턴스만 생성되고, 이 인스턴스는 프로그램이 실행되는 동안 유지
2. 전역 접근법 : 싱글톤 인스턴스는 정적 메서드를 통하여 어디서는 접근가능 -> 객체명.메서드명(); x -> 클래스명.메서드명();
3. 인스턴스의 생명주기 관리: 클래스 자체가 인스턴스 생성을 관리하므로. 다른 객체들이 인스턴스를 생성하거나 폐기할수있음.

## 장점
1. 메모리 절약 : 불필요한 인스턴스 생성을 방지하여 메모리 절약가능 (static 변수 / 메서드의 장점과 같음.)
2. 글로벌(전역적) 접근 : 전역적 접근이 가능하여 메모리 관리가 용이 -> 다만 잦은 접근 자체는 단점
3. 일관성 유지 : 애플리케이션 전반에서 하나의 인스턴스만 사용하기 때문에 상태 일관성을 유지

# 단점
1. 테스트 어려움 : 싱글톤 패턴은 전역적으로 사용괴므로 `단위 테스트`가 어려울수 있음.
2. 의존성 숨김 : 싱글톤을 남용하면 클래스간의 의존성을 추적하기 어려울 수 있음.

# 제네릭 Generic

## 개념 및 정의
- 클래스나 메서드가 다룰 데이터 타입을 미리 명시하여 재사용성과 유연성을 높이는 기술

### 타임 매개변수 (Type Parameter)
- 클래스나 메서드에서 사용할 실제 타입을 `대신하여 사용하는 매개변수`
- 일반적으로 알파벳 대문자 하나로 표기함.
    1. T(Type) : 일반 적으로 클래스타입을 나타낼 때 사용
    2. E(Element) : 컬렉션(추후 수업)의 요소를 나타낼 때 사용
    3. K(Key) : Map(추후 수업) 의 key를 나타낼 때 사용
    4. V(Value) : Map의 Value 또는 제네릭 타입의 리턴 값으로 나타낼 때 사용

### 재사용성
- 제네릭을 사용하면 다양한 자료형에 대해 하나의 클래스나 메서드를 정의 할수있어 코드의 재사용성을 높이고 중복을 줄임.

## 과제
```
ch18_generic 밑에 bmi 패키지를 생성하시오.

Person 클래스를 정의하고
field를 Stirng name / double hight / double wight로 작성하시오.
PersonMain 클래스를 생성하시오.
Bmi 클래스에서 method로 clacBmi(Person person); 형태로 정의하시오. -> return type double

printResult(Person person)를 적용하고 조건문을 사용하여
- 김일 님의 키는 xxx cm, 몸무게는 xxx kg, bmi 지수는 xxx 으로 저체중/정상/비만전단계/1단계 비만/ 2단계비만/ 3단계 비만입니다.
라고 출력할수 있도록 작성하시오

PersonMain에서 Person객체 생성, Bmi 객체를 생성한후 calcBmi() 및 printResult()를 호출하시오.
```

